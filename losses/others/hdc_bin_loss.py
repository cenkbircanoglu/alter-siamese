from __future__ import absolute_importimport torchfrom torch import nnfrom torch.autograd import Variable"""HDC methodHard-Aware Deeply Cascaded Embedding"""def similarity(inputs_):    # Compute similarity mat of deep feature    # n = inputs_.size(0)    sim = torch.matmul(inputs_, inputs_.t())    return sim# TODOclass HDC_Bin_Loss(nn.Module):    def __init__(self, margin=0.5):        super(HDC_Bin_Loss, self).__init__()        self.margin = margin        self.use_cuda = False    def forward(self, inputs, targets):        n = inputs.size(0)        eyes_ = Variable(torch.eye(n, n))        if self.use_cuda:            targets = targets.cuda()            eyes_ = eyes_.cuda()        pos_mask = targets.expand(n, n).eq(targets.expand(n, n).t())        neg_mask = eyes_.eq(eyes_) - pos_mask        pos_mask = pos_mask - eyes_.eq(1)        inputs = [inputs[:, :128], inputs[:, 128:256], inputs[:, 256:]]        sim_mats = [similarity(f_) for f_ in inputs]        pos_sims = [torch.masked_select(sim_mat, pos_mask) for sim_mat in sim_mats]        neg_sims = [torch.masked_select(sim_mat, neg_mask) for sim_mat in sim_mats]        ratio = [1, 0.5, 0.2]        loss = 0        for i in range(3):            pos_sim, neg_sim = pos_sims[i], neg_sims[i]            pos_sim, pos_idx = pos_sim.sort()            neg_sim, neg_idx = neg_sim.sort()            pos_sim = pos_sim[:int(ratio[i] * len(pos_sim))]            if len(pos_sim) > 0:                loss += (1.0 / 2) * torch.mean(                    torch.log(1 + torch.exp(2 * (self.margin - pos_sim))))            neg_sim = neg_sim[-int(ratio[i] * len(neg_sim)):]            if len(neg_sim) > 0:                loss += (1.0 / 40) * torch.mean((                    torch.log(1 + torch.exp(40 * (neg_sim - self.margin)))))        return loss    def cuda(self, device_id=None):        """Moves all model parameters and buffers to the GPU.        Arguments:            device_id (int, optional): if specified, all parameters will be                copied to that device        """        self.use_cuda = True        return self._apply(lambda t: t.cuda(device_id))def main():    data_size = 32    input_dim = 3    output_dim = 2    num_class = 4    x = Variable(torch.rand(data_size, input_dim), requires_grad=False)    w = Variable(torch.rand(input_dim, output_dim), requires_grad=True)    inputs = x.mm(w)    y_ = 8 * list(range(num_class))    targets = Variable(torch.IntTensor(y_))    print(HDC_Bin_Loss()(inputs, targets))if __name__ == '__main__':    main()    print('Congratulations to you!')